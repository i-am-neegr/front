<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku в Telegram</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f0f0f0; text-align: center; padding: 10px; }
        #board { display: grid; grid-template-columns: repeat(9, 40px); gap: 1px; margin: 20px auto; max-width: 360px; }
        .cell { width: 40px; height: 40px; text-align: center; font-size: 20px; border: 1px solid #ccc; }
        .cell.filled { background: #eee; pointer-events: none; }
        .cell.error { background: #ffcccc; }
        .cell.selected { border: 2px solid #007bff; }
        button { margin: 10px 5px; padding: 10px 20px; font-size: 16px; }
        #status { font-size: 18px; margin: 10px; }
        #players { margin: 10px; }
        .thick { border-width: 3px !important; }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<h2>Sudoku Multiplayer</h2>
<select id="difficulty">
    <option value="easy">Легко</option>
    <option value="medium">Средне</option>
    <option value="hard">Сложно</option>
</select>
<button id="create">Создать игру</button>
<button id="share" style="display:none;">Поделиться</button>
<div id="status">Ожидание...</div>
<div id="players"></div>
<div id="board"></div>
<button id="pass" style="display:none;">Пропустить ход</button>

<script>
    const tg = window.Telegram.WebApp;
    tg.ready();
    tg.expand();

    const userId = tg.initDataUnsafe.user?.id?.toString() || 'guest_' + Math.random().toString(36).slice(2);
    const userName = tg.initDataUnsafe.user?.username || tg.initDataUnsafe.user?.first_name || 'Guest';
    const initData = tg.initData; // Сырая строка для верификации
    const botName = 'sudoku52bot'; // Замени на имя твоего бота
    const backendUrl = 'https://sudoku-2ofn.onrender.com'; // Замени на свой backend URL

    let sessionId = null;
    let currentTurnIndex = 0;
    let players = [];
    let pollingInterval = null;

    // Авто-присоединение по startapp
    const urlParams = new URLSearchParams(window.location.search);
    const startApp = urlParams.get('startapp');
    if (startApp) {
        sessionId = startApp;
        joinSession();
    }

    // Создание игры
    document.getElementById('create').addEventListener('click', () => {
        const difficulty = document.getElementById('difficulty').value;
        fetch(`${backendUrl}/create?difficulty=${difficulty}&userId=${userId}&name=${encodeURIComponent(userName)}&initData=${encodeURIComponent(initData)}`, { method: 'POST' })
            .then(handleResponse)
            .then(data => {
                sessionId = data.sessionId;
                players = data.players;
                currentTurnIndex = data.currentTurnIndex;
                renderBoard(data.board);
                renderPlayers();
                updateStatus();
                showButtons();
                startPolling();
            })
            .catch(handleError);
    });

    // Присоединение
    function joinSession() {
        fetch(`${backendUrl}/join/${sessionId}?userId=${userId}&name=${encodeURIComponent(userName)}&initData=${encodeURIComponent(initData)}`, { method: 'POST' })
            .then(handleResponse)
            .then(data => {
                players = data.players;
                currentTurnIndex = data.currentTurnIndex;
                renderBoard(data.board);
                renderPlayers();
                updateStatus();
                showButtons();
                startPolling();
                if (data.finished) {
                    tg.showAlert('Игра завершена!');
                }
            })
            .catch(handleError);
    }

    // Polling для обновлений
    function startPolling() {
        if (pollingInterval) clearInterval(pollingInterval);
        pollingInterval = setInterval(() => {
            if (sessionId) {
                fetch(`${backendUrl}/${sessionId}?initData=${encodeURIComponent(initData)}`)
                    .then(handleResponse)
                    .then(data => {
                        players = data.players;
                        currentTurnIndex = data.currentTurnIndex;
                        renderBoard(data.board);
                        renderPlayers();
                        updateStatus();
                        if (data.finished) {
                            tg.showAlert('Игра завершена! Судоку решено.');
                            clearInterval(pollingInterval);
                        }
                    })
                    .catch(handleError);
            }
        }, 3000);
    }

    // Поделиться
    document.getElementById('share').addEventListener('click', () => {
        const url = `https://t.me/${botName}/app?startapp=${sessionId}`;
        navigator.clipboard.writeText(url)
            .then(() => tg.showPopup({ message: 'Ссылка скопирована!' }))
            .catch(() => tg.showPopup({ message: 'Не удалось скопировать. Ссылка: ' + url }));
    });

    // Пропустить ход
    document.getElementById('pass').addEventListener('click', () => {
        if (isMyTurn()) {
            fetch(`${backendUrl}/${sessionId}/pass?userId=${userId}&initData=${encodeURIComponent(initData)}`, { method: 'POST' })
                .then(handleResponse)
                .then(data => {
                    if (data.success) {
                        currentTurnIndex = data.currentTurnIndex;
                        updateStatus();
                    }
                })
                .catch(handleError);
        } else {
            tg.showPopup({ message: 'Не ваша очередь!' });
        }
    });

    // Обработчик ответов (проверка на ошибки)
    async function handleResponse(res) {
        if (!res.ok) {
            const err = await res.text();
            throw new Error(err || 'Ошибка запроса');
        }
        return res.json();
    }

    function handleError(err) {
        console.error(err);
        tg.showPopup({ message: 'Ошибка: ' + err.message + '. Возможно, проблема с авторизацией.' });
    }

    function showButtons() {
        document.getElementById('share').style.display = 'inline-block';
        document.getElementById('pass').style.display = 'inline-block';
    }

    function updateStatus() {
        let statusText = `Игроков: ${players.length}. `;
        if (players.length > 1) {
            statusText += `Ход: ${players[currentTurnIndex].name} `;
        }
        statusText += isMyTurn() ? '(Ваш ход)' : '(Ожидание хода)';
        document.getElementById('status').textContent = statusText;
    }

    function isMyTurn() {
        const myIndex = players.findIndex(p => p.id === userId);
        return players.length === 1 || myIndex === currentTurnIndex;
    }

    function renderPlayers() {
        const playersDiv = document.getElementById('players');
        playersDiv.innerHTML = 'Игроки: ' + players.map(p => p.name).join(', ');
    }

    function renderBoard(board) {
        const boardDiv = document.getElementById('board');
        boardDiv.innerHTML = '';
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const cell = document.createElement('input');
                cell.className = 'cell';
                cell.type = 'number';
                cell.min = 1; cell.max = 9;
                cell.value = board[row][col] || '';
                cell.dataset.row = row;
                cell.dataset.col = col;
                if (board[row][col] !== 0) {
                    cell.classList.add('filled');
                    cell.disabled = true;
                } else {
                    cell.addEventListener('input', (e) => {
                        const num = parseInt(e.target.value);
                        if (num >= 1 && num <= 9 && isMyTurn()) {
                            fetch(`${backendUrl}/${sessionId}/move?userId=${userId}&row=${row}&col=${col}&value=${num}&initData=${encodeURIComponent(initData)}`, { method: 'POST' })
                                .then(handleResponse)
                                .then(data => {
                                    if (data.success) {
                                        renderBoard(data.board);
                                        currentTurnIndex = data.currentTurnIndex;
                                        updateStatus();
                                        if (data.finished) {
                                            tg.showAlert('Поздравляем! Судоку решено.');
                                        }
                                    } else {
                                        e.target.classList.add('error');
                                        setTimeout(() => e.target.classList.remove('error'), 1000);
                                        e.target.value = '';
                                    }
                                })
                                .catch(handleError);
                        } else {
                            e.target.value = '';
                        }
                    });
                }
                if (row % 3 === 0) cell.style.borderTop = '3px solid #333';
                if (col % 3 === 0) cell.style.borderLeft = '3px solid #333';
                if (row === 8) cell.style.borderBottom = '3px solid #333';
                if (col === 8) cell.style.borderRight = '3px solid #333';
                boardDiv.appendChild(cell);
            }
        }
    }
</script>
</body>
</html>